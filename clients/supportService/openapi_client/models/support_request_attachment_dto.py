# coding: utf-8

"""
    SupportService

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 2.0.1.4089
    Contact: support@fenix-alliance.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class SupportRequestAttachmentDto(BaseModel):
    """
    SupportRequestAttachmentDto
    """ # noqa: E501
    id: Optional[StrictStr] = None
    timestamp: Optional[datetime] = None
    notes: Optional[StrictStr] = None
    title: Optional[StrictStr] = None
    author: Optional[StrictStr] = None
    is_folder: Optional[StrictBool] = Field(default=None, alias="isFolder")
    hash: Optional[StrictStr] = None
    file_url: Optional[StrictStr] = Field(default=None, alias="fileUrl")
    file_path: Optional[StrictStr] = Field(default=None, alias="filePath")
    file_name: Optional[StrictStr] = Field(default=None, alias="fileName")
    abstract: Optional[StrictStr] = None
    key_words: Optional[StrictStr] = Field(default=None, alias="keyWords")
    metadata: Optional[StrictStr] = None
    file_length: Optional[StrictInt] = Field(default=None, alias="fileLength")
    content_type: Optional[StrictStr] = Field(default=None, alias="contentType")
    parent_file_id: Optional[StrictStr] = Field(default=None, alias="parentFileId")
    valid_response: Optional[StrictBool] = Field(default=None, alias="validResponse")
    user_id: Optional[StrictStr] = Field(default=None, alias="userId")
    tenant_id: Optional[StrictStr] = Field(default=None, alias="tenantId")
    enrollment_id: Optional[StrictStr] = Field(default=None, alias="enrollmentId")
    social_profile_id: Optional[StrictStr] = Field(default=None, alias="socialProfileId")
    folder_path: Optional[StrictStr] = Field(default=None, alias="folderPath")
    support_request_id: Optional[StrictStr] = Field(default=None, alias="supportRequestID")
    __properties: ClassVar[List[str]] = ["id", "timestamp", "notes", "title", "author", "isFolder", "hash", "fileUrl", "filePath", "fileName", "abstract", "keyWords", "metadata", "fileLength", "contentType", "parentFileId", "validResponse", "userId", "tenantId", "enrollmentId", "socialProfileId", "folderPath", "supportRequestID"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SupportRequestAttachmentDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if timestamp (nullable) is None
        # and model_fields_set contains the field
        if self.timestamp is None and "timestamp" in self.model_fields_set:
            _dict['timestamp'] = None

        # set to None if notes (nullable) is None
        # and model_fields_set contains the field
        if self.notes is None and "notes" in self.model_fields_set:
            _dict['notes'] = None

        # set to None if title (nullable) is None
        # and model_fields_set contains the field
        if self.title is None and "title" in self.model_fields_set:
            _dict['title'] = None

        # set to None if author (nullable) is None
        # and model_fields_set contains the field
        if self.author is None and "author" in self.model_fields_set:
            _dict['author'] = None

        # set to None if hash (nullable) is None
        # and model_fields_set contains the field
        if self.hash is None and "hash" in self.model_fields_set:
            _dict['hash'] = None

        # set to None if file_url (nullable) is None
        # and model_fields_set contains the field
        if self.file_url is None and "file_url" in self.model_fields_set:
            _dict['fileUrl'] = None

        # set to None if file_path (nullable) is None
        # and model_fields_set contains the field
        if self.file_path is None and "file_path" in self.model_fields_set:
            _dict['filePath'] = None

        # set to None if file_name (nullable) is None
        # and model_fields_set contains the field
        if self.file_name is None and "file_name" in self.model_fields_set:
            _dict['fileName'] = None

        # set to None if abstract (nullable) is None
        # and model_fields_set contains the field
        if self.abstract is None and "abstract" in self.model_fields_set:
            _dict['abstract'] = None

        # set to None if key_words (nullable) is None
        # and model_fields_set contains the field
        if self.key_words is None and "key_words" in self.model_fields_set:
            _dict['keyWords'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if content_type (nullable) is None
        # and model_fields_set contains the field
        if self.content_type is None and "content_type" in self.model_fields_set:
            _dict['contentType'] = None

        # set to None if parent_file_id (nullable) is None
        # and model_fields_set contains the field
        if self.parent_file_id is None and "parent_file_id" in self.model_fields_set:
            _dict['parentFileId'] = None

        # set to None if user_id (nullable) is None
        # and model_fields_set contains the field
        if self.user_id is None and "user_id" in self.model_fields_set:
            _dict['userId'] = None

        # set to None if tenant_id (nullable) is None
        # and model_fields_set contains the field
        if self.tenant_id is None and "tenant_id" in self.model_fields_set:
            _dict['tenantId'] = None

        # set to None if enrollment_id (nullable) is None
        # and model_fields_set contains the field
        if self.enrollment_id is None and "enrollment_id" in self.model_fields_set:
            _dict['enrollmentId'] = None

        # set to None if social_profile_id (nullable) is None
        # and model_fields_set contains the field
        if self.social_profile_id is None and "social_profile_id" in self.model_fields_set:
            _dict['socialProfileId'] = None

        # set to None if folder_path (nullable) is None
        # and model_fields_set contains the field
        if self.folder_path is None and "folder_path" in self.model_fields_set:
            _dict['folderPath'] = None

        # set to None if support_request_id (nullable) is None
        # and model_fields_set contains the field
        if self.support_request_id is None and "support_request_id" in self.model_fields_set:
            _dict['supportRequestID'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SupportRequestAttachmentDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "timestamp": obj.get("timestamp"),
            "notes": obj.get("notes"),
            "title": obj.get("title"),
            "author": obj.get("author"),
            "isFolder": obj.get("isFolder"),
            "hash": obj.get("hash"),
            "fileUrl": obj.get("fileUrl"),
            "filePath": obj.get("filePath"),
            "fileName": obj.get("fileName"),
            "abstract": obj.get("abstract"),
            "keyWords": obj.get("keyWords"),
            "metadata": obj.get("metadata"),
            "fileLength": obj.get("fileLength"),
            "contentType": obj.get("contentType"),
            "parentFileId": obj.get("parentFileId"),
            "validResponse": obj.get("validResponse"),
            "userId": obj.get("userId"),
            "tenantId": obj.get("tenantId"),
            "enrollmentId": obj.get("enrollmentId"),
            "socialProfileId": obj.get("socialProfileId"),
            "folderPath": obj.get("folderPath"),
            "supportRequestID": obj.get("supportRequestID")
        })
        return _obj


